%{
	#include "parser.h"
	#include "hw3_aux.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
	extern int yylex();
	int yyerror(const char * message);

	symbol* symbols = new symbol() ;
    string func_ret_type;
    int loopsCnt=0;
%}


%right ASSIGN
%left OR
%left AND
%left PRERELOP
%nonassoc POSTRELOP
%left PREBINOP
%left POSTBINOP
%right NOT
%left LPAREN RPAREN
%left LBRACE RBRACE
%right IF
%nonassoc ELSE
%nonassoc WHILE
%nonassoc VOID
%nonassoc ID
%nonassoc INT
%nonassoc BYTE
%nonassoc STRING
%nonassoc BOOL
%nonassoc NUM
%nonassoc B
%nonassoc RETURN
%nonassoc CONTINUE
%nonassoc BREAK
%nonassoc TRUE
%nonassoc FALSE
%nonassoc SC
%nonassoc COMMA

%%


Program : INIT Funcs  {symbols->does_main_exist(); output::endScope(); symbols->PrintScope(symbols->t_stack[0]); }
;

INIT: {symbols->init_global_table();}
;

Funcs : FuncDecl Funcs  								{}
      | 			    								{}
;

FuncDecl :  RetType ID  LPAREN  Formals RPAREN LBRACE Statements RBRACE 	{func_ret_type= $1->type; symbols->decl_func($2->name , $4->type , $1->type , $4->name  ,yylineno) ;}
;

RetType : Type  															{$$ = new Node($1->name, $1->type);}
        | VOID 																{$$ = new Node($1->name, $1->type);}
;

Formals : FormalsList   											{$$ = new Node($1->name, $1->type);}
        |						    											{$$ = new Node("", "");}
;

FormalsList : FormalDecl    				  {symbols->add_var($1->name , $1->type , false,yylineno); $$ = new Node($1->name, $1->type);}
            |  FormalDecl COMMA FormalsList   {symbols->add_var($1->name , $1->type , false,yylineno); $$ = new Node($1->name + "," + $3->name, $1->type + "," + $3->type);}
;

FormalDecl : Type ID    				    	{$$ = new Node($2->name, $1->type);}
;

Statements: Statement 								{}
          | Statements Statement 					{}
;

Statement : LBRACE NEW_SCOPE Statements RBRACE 	      {output::endScope(); symbols->PrintScope(symbols->t_stack.back()); symbols->remove_scope();}
	      	|	Type ID SC 							  {symbols->add_var($2->name, $1->type, false, yylineno);}
	      	|	Type ID ASSIGN Exp SC 				  {symbols->check_types($1->type, $4->type, yylineno); symbols->add_var($2->name, $1->type, false, yylineno); symbols->assign($2->name, $4->type, yylineno);}
	      	|	ID ASSIGN Exp SC 		              {symbols->assign($1->name, $2->type, yylineno);}
	      	|	Call SC										                {}
	      	|	RETURN SC									                {symbols->check_types("void", func_ret_type , yylineno);}
	      	|	RETURN Exp SC 						 		            {symbols->check_types($1->type, func_ret_type , yylineno);}
	      	|	IF NEW_SCOPE LPAREN Exp {symbols->check_types("bool",$4->type, yylineno);} RPAREN Statement                                   {output::endScope(); symbols->PrintScope(symbols->t_stack.back()); symbols->remove_scope();}
	      	//|	IF NEW_SCOPE LPAREN Exp {symbols->check_types("bool",$4->type, yylineno);} RPAREN Statement {output::endScope(); symbols->PrintScope(symbols->t_stack.back()); symbols->remove_scope();} ELSE NEW_SCOPE Statement   {output::endScope(); symbols->PrintScope(symbols->t_stack.back()); symbols->remove_scope();}
	      	|	WHILE {loopsCnt++;} NEW_SCOPE LPAREN Exp {symbols->check_types("bool",$5->type, yylineno);} RPAREN Statement 				        {output::endScope(); symbols->PrintScope(symbols->t_stack.back()); symbols->remove_scope(); loopsCnt--;}
	      	//|	WHILE {loopsCnt++;} NEW_SCOPE LPAREN Exp {symbols->check_types("bool",$5->type, yylineno);} RPAREN Statement ELSE NEW_SCOPE Statement  {output::endScope(); symbols->PrintScope(symbols->t_stack.back()); symbols->remove_scope(); loopsCnt--;}
	      	|	BREAK SC	 	   {symbols->insideLoop(loopsCnt , "break" , yylineno);}
	      	|	CONTINUE SC	       {symbols->insideLoop(loopsCnt , "continue" , yylineno);}
;

NEW_SCOPE :     {symbols->add_scope(); }
;



Call : ID LPAREN ExplList RPAREN  {$$=new Node("", symbols->funcType($1->name, $3->type , yylineno));}
	 | ID LPAREN RPAREN			 		  	{$$=new Node("", symbols->funcType($1->name, "", yylineno));}
;

ExplList : Exp 									{$$ = new Node($1->name, $1->type);}
		 |	Exp COMMA ExplList  		{$$ = new Node($1->name + "," + $3->name, $1->type + "," + $3->type);}
;

Type :  INT   									{$$ = new Node("", "int");}
	 |	BYTE 									{$$ = new Node("", "byte");}
     |	BOOL								    {$$ = new Node("", "bool");}
;

Exp : LPAREN Exp RPAREN				 {$$ = new Node($2->name, $2->type);}
	|	Exp PREBINOP Exp				 	 {symbols->check_types($1->type, "int", yylineno); symbols->check_types($3->type, "int", yylineno); $$ = new Node("", symbols->larger($1->type, $3->type));}
	|	Exp POSTBINOP Exp				 	 {symbols->check_types($1->type, "int", yylineno); symbols->check_types($3->type, "int", yylineno); $$ = new Node("", symbols->larger($1->type, $3->type));}
	|	ID 								 	 {const arg* var=symbols->get_var($1->name,yylineno , false);  $$ = new Node(var->name, var->type);}
	|	Call							 				 {$$ = new Node("", $1->type);}
	|	NUM 							 				 {$$ = new Node("", "int");}
	|	NUM B							 				 {$$ = new Node("", "byte");}
	|	STRING 							 			 {$$ = new Node("", "string");}
	|	TRUE							 				 {$$ = new Node("true", "bool");}
	|	FALSE 							 			 {$$ = new Node("false", "bool");}
	|	NOT Exp 						 			 {symbols->check_types($2->type, "bool", yylineno); $$ = new Node("", "bool");}
	|	Exp AND Exp 					 		 {symbols->check_types($1->type, "bool", yylineno); symbols->check_types($3->type, "bool", yylineno); $$ = new Node("", "bool");}
	|	Exp OR Exp 						 		 {symbols->check_types($1->type, "bool", yylineno); symbols->check_types($3->type, "bool", yylineno); $$ = new Node("", "bool");}
	|	Exp PRERELOP Exp 		 	     {symbols->check_types($1->type, "int", yylineno); symbols->check_types($3->type, "int", yylineno); $$ = new Node("", "bool");}
	|	Exp POSTRELOP Exp 		 		 {symbols->check_types($1->type, "int", yylineno); symbols->check_types($3->type, "int", yylineno); $$ = new Node("", "bool");}
;


%%

int main()
{
	yyparse();
}

int yyerror(const char * msg)
{
	output::errorSyn(yylineno);
	exit(0);
}
